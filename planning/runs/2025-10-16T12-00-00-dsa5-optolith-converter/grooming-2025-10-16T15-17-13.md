# Grooming Notes — 2025-10-17 Optolith Converter UI

## Participants
- Scrum Master Agent (facilitator)
- Product Owner Agent (scope & UX)
- Developer Agent A (frontend & routing)
- Developer Agent B (worker/data handling)
- QA Agent (testing strategy)

## Backlog Under Review
- Story DSA5-OPT-005 — Optolith converter UI integration

---

### Round 1
- **Scrum Master:** Frames session around validating UX scope and identifying blockers before sprint planning.
- **Product Owner:** Emphasizes “paste stat block → download JSON” simplicity; warns against exposing internal dataset status in UI.
- **Developer A:** Notes need for example loader button using curated samples to help users unfamiliar with format.
- **Developer B:** Highlights requirement for manifest load error handling; suggests initializing worker only after dataset fetch succeeds.
- **QA Agent:** Requests explicit acceptance on stat block length validation and localStorage caching so tests cover these scenarios.

### Round 2
- **Scrum Master:** Logs action items: add AC for length limit, confirm sample loader feature, document cache clearing.
- **Product Owner:** Approves providing “Use Sample” CTA, asks for copy that clarifies data never leaves browser.
- **Developer A:** Recommends progressive enhancement: show conversion spinner and disable button to avoid double submits.
- **Developer B:** Wants typed message channel between UI and worker for standardized success/error payloads.
- **QA Agent:** Plans to simulate corrupt dataset responses; needs deterministic error message string for assertions.

### Round 3
- **Scrum Master:** Confirms dependencies on Stories 001–004; urges front-end to fail fast if manifest fetch rejects.
- **Product Owner:** Requests final download file name pattern `<npc>-optolith.json`; fallback to timestamp if no name detected.
- **Developer A:** Suggests storing last successful result (JSON + warnings) in localStorage with timestamp and exposing “Load Last Result”.
- **Developer B:** Notes need to chunk dataset fetches lazily to keep first render quick; warns about bundler asset URLs.
- **QA Agent:** Calls for acceptance around clearing warning list when user edits input before reconverting.

### Round 4
- **Scrum Master:** Raises question about keyboard shortcuts; proposes documenting them as optional enhancement.
- **Product Owner:** Accepts shortcuts but flags them non-blocking; main priority is accessible buttons.
- **Developer A:** Points out we must sanitize JSON preview to prevent huge DOM nodes—cap lines and provide copy button.
- **Developer B:** Suggests capturing worker exceptions (e.g., JSON.parse errors) with try/catch and posting normalized error objects.
- **QA Agent:** Recommends adding Cypress smoke scenario once UI exists to verify download flow manually.

### Round 5
- **Scrum Master:** Summarizes commitments and schedules follow-up grooming if Stories 001–004 change interfaces.
- **Product Owner:** Will craft microcopy for warning banners and “try again later” messaging.
- **Developer A:** Volunteers to draft component skeleton after dependencies expose stable APIs.
- **Developer B:** Will publish worker message contract doc in repo for QA reference.
- **QA Agent:** Takes action to outline Vitest suites for worker, component, and caching behavior.

---

## Action Items
- Add acceptance criterion covering maximum stat block length validation (Developer A).
- Add acceptance criterion for sample stat block loader and last-result recall (Scrum Master to update story).
- Define worker message schema and share with QA (Developer B).
- Provide user-facing copy for warning and error banners (Product Owner).
- Document manual test flow for corrupt dataset assets (QA Agent).

## Follow-Up
- New grooming checkpoint after worker contract is documented or if dataset manifest structure changes.
